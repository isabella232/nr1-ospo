import { UserSecretsMutation, UserSecretsQuery } from '@newrelic/nr1-community';
import {
  UserStorageMutation,
  UserStorageQuery,
  AccountStorageQuery,
} from 'nr1';
import React from 'react';
import PropTypes from 'prop-types';
import { id } from '../../../nr1.json';

// TODO: clear previous values on version change
/** Increment this value to force-clear all user settings on publish */
const DASHBOARD_MAJOR_VERSION = 2;
const GH_TOKEN_KEY = `${id}-githubToken-v1`;
const SETTINGS_KEY = `${id}-ospoSettings-v1`;
const EMPLOYEE_METADATA_ACCOUNT_ID = ***REMOVED***;
const EMPLOYEE_METADATA_COLLECTION = `${id}-employeeMetadata-v${DASHBOARD_MAJOR_VERSION}`;
const EMPLOYEE_METADATA_DOCUMENT = EMPLOYEE_METADATA_COLLECTION;

/**
 * Component used to read and write the NerdStorage values relevant to this
 * dashboard. Similar to the existing NerdStorage components, this component
 * works both declaratively (as a component) and imperatively (static
 * functions).
 */
export default class SettingsQuery extends React.Component {
  /**
   * Remove the PAT from NerdVault.
   *
   * @returns {Promise<void>}
   */
  static async removeToken() {
    await UserSecretsMutation.mutate({
      actionType: UserSecretsMutation.ACTION_TYPE.DELETE_SECRET,
      name: GH_TOKEN_KEY,
    });
  }

  /**
   * Read the PAT from NerdVault.
   *
   * @returns {Promise<?string>} The PAT, or falsey if the token does not exist.
   */
  static async readToken() {
    const { data } = await UserSecretsQuery.query({
      name: GH_TOKEN_KEY,
    });
    return data?.value;
  }

  /**
   * Save the PAT to NerdVault
   *
   * @returns {Promise<void>}
   */
  static async writeToken(token) {
    await UserSecretsMutation.mutate({
      actionType: UserSecretsMutation.ACTION_TYPE.WRITE_SECRET,
      name: GH_TOKEN_KEY,
      value: token,
    });
  }

  /**
   * @typedef {Object} Profile An object contains the settings for a
   *     single dashboard profile.
   * @property {string[]} settings.repos A list of repositories including the
   *     owner to scan. (`owner/repo`).
   * @property {string[]} settings.labels A list of Issue/PR labels to denylist.
   * @property {string[]} settings.users A list of GitHub logins to include in
   *     the employee list.
   * @property {number} settings.staleTime A millisecond time duration used
   *     during stale categorization.
   * @property {string} settings.profileName The name of the profile, human
   *     readable.
   */

  /**
   * Write user settings to NerdStorage.
   *
   * @param {Profile[]} profileList A list of profiles to save to persistent
   *     storage.
   * @returns {Promise<void>}
   */
  static async writeSettings(profileList) {
    // filter the profile list to allowed keys
    const profiles = profileList.map(
      ({ repos, labels, users, staleTime, profileName }) => ({
        repos,
        labels,
        users,
        staleTime,
        profileName,
      })
    );
    await UserStorageMutation.mutate({
      actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT,
      collection: SETTINGS_KEY,
      documentId: SETTINGS_KEY,
      document: {
        version: DASHBOARD_MAJOR_VERSION,
        profiles,
      },
    });
  }

  /**
   * Read user settings from NerdStorage
   *
   * @returns {Promise<?Profile[]>} An array containing the stored
   *     user settings.
   */
  static async readSettings() {
    const { data } = await UserStorageQuery.query({
      collection: SETTINGS_KEY,
      documentId: SETTINGS_KEY,
    });
    if (!data) return data;
    // translate between version 1 and version 2 data if needed
    if (!data.version) {
      // wrap the current data into a profile
      const profiles = [{ ...data, profileName: 'Autogenerated Profile Name' }];
      // write that data to settings to upgrade the user
      await SettingsQuery.writeSettings(profiles);
      return profiles;
    }
    return data.profiles;
  }

  /**
   * Read employee metadata from account-based nerdstorage. At the moment this
   * returns an array of usernames associated with the current company.
   *
   * @returns {Promise<string[]>} An array of usernames, or an empty array of
   *     none were found.
   */
  static async readEmployeeData() {
    const { data } = await AccountStorageQuery.query({
      accountId: EMPLOYEE_METADATA_ACCOUNT_ID,
      collection: EMPLOYEE_METADATA_COLLECTION,
      documentId: EMPLOYEE_METADATA_DOCUMENT,
    });
    return data?.users;
  }

  static propTypes = {
    /** ({ loading, token, settings, users }) => JSX */
    children: PropTypes.func.isRequired,
  };

  constructor(props = {}) {
    super(props);
    this.state = {
      loading: true,
    };
  }

  async componentDidMount() {
    const [token, settings, users] = await Promise.all([
      SettingsQuery.readToken(),
      SettingsQuery.readSettings(),
      SettingsQuery.readEmployeeData(),
    ]);
    this.setState({
      loading: false,
      token,
      settings,
      users,
    });
  }

  render() {
    return this.props.children(this.state);
  }
}
